const express = require('express');
const multer = require('multer');
const FormData = require('form-data');
const fetch = require('node-fetch');
const fs = require('fs');
const path = require('path');
const cors = require('cors');

const app = express();

// Middleware
app.use(cors());
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(express.static('public'));
app.use('/temp', express.static('temp'));

// File upload configuration
const upload = multer({ 
    dest: 'temp/',
    limits: { fileSize: 25 * 1024 * 1024 },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('audio/')) {
            cb(null, true);
        } else {
            cb(new Error('Only audio files are allowed!'), false);
        }
    }
});

// Environment variables
const TWILIO_ACCOUNT_SID = process.env.TWILIO_ACCOUNT_SID || 'SKf6fc56929a2232e58411953a1bf59557';
const TWILIO_AUTH_TOKEN = process.env.TWILIO_AUTH_TOKEN || 'o1i1uwDh3Rg0I4bhAI3x1rCxuT7d5XXg';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || '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';
const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY || 'sk_ec886e33c31e94e018a6821852bb432544d5b1d4a5585ae5';
const ELEVENLABS_VOICE_ID = process.env.ELEVENLABS_VOICE_ID || 'zEOxFAFypY6dhA5834R6';
const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

// Stats tracking
const stats = {
    totalMessages: 0,
    successfulTranslations: 0,
    errors: 0,
    averageProcessTime: 18
};

const processedMessages = new Set();

// Utility functions
async function downloadFile(url, filepath) {
    const response = await fetch(url, {
        headers: {
            'Authorization': `Basic ${Buffer.from(`${TWILIO_ACCOUNT_SID}:${TWILIO_AUTH_TOKEN}`).toString('base64')}`
        }
    });
    
    if (!response.ok) throw new Error(`Failed to download: ${response.statusText}`);
    
    const buffer = await response.buffer();
    fs.writeFileSync(filepath, buffer);
    return filepath;
}

async function speechToText(audioPath) {
    const formData = new FormData();
    formData.append('file', fs.createReadStream(audioPath));
    formData.append('model', 'whisper-1');
    formData.append('language', 'ru');
    
    const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
            ...formData.getHeaders()
        },
        body: formData
    });
    
    if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || response.statusText}`);
    }
    
    const result = await response.json();
    return result.text;
}

async function translateText(text) {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            model: 'gpt-3.5-turbo',
            messages: [
                {
                    role: 'system',
                    content: 'Translate the following Russian text to Portuguese (Brazil). Respond only with the translation, no explanations.'
                },
                {
                    role: 'user',
                    content: text
                }
            ],
            max_tokens: 500,
            temperature: 0.3
        })
    });
    
    if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || response.statusText}`);
    }
    
    const result = await response.json();
    return result.choices[0].message.content.trim();
}

async function textToSpeech(text, outputPath) {
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}`, {
        method: 'POST',
        headers: {
            'Accept': 'audio/mpeg',
            'Content-Type': 'application/json',
            'xi-api-key': ELEVENLABS_API_KEY
        },
        body: JSON.stringify({
            text: text,
            model_id: 'eleven_multilingual_v2',
            voice_settings: {
                stability: 0.5,
                similarity_boost: 0.8,
                style: 0.5,
                use_speaker_boost: true
            }
        })
    });
    
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`ElevenLabs API error: ${response.statusText}`);
    }
    
    const buffer = await response.buffer();
    fs.writeFileSync(outputPath, buffer);
    return outputPath;
}

async function sendAudioMessage(to, from, audioPath) {
    const publicUrl = `${BASE_URL}/temp/${path.basename(audioPath)}`;
    
    const formData = new FormData();
    formData.append('From', from);
    formData.append('To', to);
    formData.append('MediaUrl', publicUrl);
    
    const response = await fetch(`https://api.twilio.com/2010-04-01/Accounts/${TWILIO_ACCOUNT_SID}/Messages.json`, {
        method: 'POST',
        headers: {
            'Authorization': `Basic ${Buffer.from(`${TWILIO_ACCOUNT_SID}:${TWILIO_AUTH_TOKEN}`).toString('base64')}`,
            ...formData.getHeaders()
        },
        body: formData
    });
    
    return response.json();
}

// Main processing function
async function processVoiceMessage(mediaUrl, from, to, isWebTest = false) {
    const messageId = `${from}_${Date.now()}`;
    const startTime = Date.now();
    
    if (processedMessages.has(messageId)) {
        console.log('Message already processed, skipping...');
        return { error: 'Already processed' };
    }
    
    stats.totalMessages++;
    
    try {
        console.log('🎤 Processing voice message...');
        
        const tempAudioPath = path.join('temp', `input_${Date.now()}.ogg`);
        if (mediaUrl.startsWith('http')) {
            await downloadFile(mediaUrl, tempAudioPath);
        } else {
            fs.copyFileSync(mediaUrl, tempAudioPath);
        }
        console.log('✅ Audio downloaded');
        
        const russianText = await speechToText(tempAudioPath);
        console.log('🗣️ Russian text:', russianText);
        
        const portugueseText = await translateText(russianText);
        console.log('🌍 Portuguese text:', portugueseText);
        
        const outputAudioPath = path.join('temp', `output_${Date.now()}.mp3`);
        await textToSpeech(portugueseText, outputAudioPath);
        console.log('🔊 Audio generated');
        
        if (!isWebTest) {
            await sendAudioMessage(from, to, outputAudioPath);
            console.log('📱 Message sent!');
        }
        
        processedMessages.add(messageId);
        stats.successfulTranslations++;
        
        const processingTime = Math.round((Date.now() - startTime) / 1000);
        stats.averageProcessTime = Math.round((stats.averageProcessTime + processingTime) / 2);
        
        setTimeout(() => {
            try {
                if (fs.existsSync(tempAudioPath)) fs.unlinkSync(tempAudioPath);
            } catch (err) {
                console.log('Cleanup error:', err.message);
            }
        }, 5 * 60 * 1000);
        
        return {
            success: true,
            russianText,
            portugueseText,
            audioPath: outputAudioPath,
            audioUrl: `${BASE_URL}/temp/${path.basename(outputAudioPath)}`,
            processingTime
        };
        
    } catch (error) {
        console.error('❌ Processing error:', error.message);
        stats.errors++;
        
        if (!isWebTest) {
            const errorFormData = new FormData();
            errorFormData.append('From', to);
            errorFormData.append('To', from);
            errorFormData.append('Body', 'Desculpe, houve um erro ao processar sua mensagem de voz. Tente novamente.');
            
            await fetch(`https://api.twilio.com/2010-04-01/Accounts/${TWILIO_ACCOUNT_SID}/Messages.json`, {
                method: 'POST',
                headers: {
                    'Authorization': `Basic ${Buffer.from(`${TWILIO_ACCOUNT_SID}:${TWILIO_AUTH_TOKEN}`).toString('base64')}`,
                    ...errorFormData.getHeaders()
                },
                body: errorFormData
            });
        }
        
        return { error: error.message };
    }
}

// Routes
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.post('/webhook', async (req, res) => {
    console.log('📨 Received webhook:', req.body);
    
    const { From, To, MediaUrl0, MediaContentType0 } = req.body;
    
    if (MediaUrl0 && (MediaContentType0.includes('audio') || MediaContentType0.includes('ogg'))) {
        processVoiceMessage(MediaUrl0, From, To).catch(console.error);
        
        res.set('Content-Type', 'text/xml');
        res.send(`
            <?xml version="1.0" encoding="UTF-8"?>
            <Response>
                <Message>🔄 Processando sua mensagem de voz...</Message>
            </Response>
        `);
    } else {
        res.set('Content-Type', 'text/xml');
        res.send(`
            <?xml version="1.0" encoding="UTF-8"?>
            <Response>
                <Message>👋 Olá! Envie uma mensagem de voz em russo e eu traduzirei para português!</Message>
            </Response>
        `);
    }
});

app.post('/api/translate', upload.single('audio'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No audio file provided' });
        }
        
        console.log('🌐 Web test translation request');
        const result = await processVoiceMessage(req.file.path, 'web-user', 'web-bot', true);
        
        if (result.error) {
            return res.status(500).json({ error: result.error });
        }
        
        res.json({
            success: true,
            russianText: result.russianText,
            portugueseText: result.portugueseText,
            audioUrl: result.audioUrl,
            processingTime: result.processingTime
        });
        
    } catch (error) {
        console.error('API error:', error);
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/health', async (req, res) => {
    try {
        const healthChecks = {
            server: true,
            timestamp: new Date().toISOString()
        };
        
        try {
            const openaiTest = await fetch('https://api.openai.com/v1/models', {
                headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` }
            });
            healthChecks.openai = openaiTest.ok;
        } catch {
            healthChecks.openai = false;
        }
        
        try {
            const elevenlabsTest = await fetch('https://api.elevenlabs.io/v1/voices', {
                headers: { 'xi-api-key': ELEVENLABS_API_KEY }
            });
            healthChecks.elevenlabs = elevenlabsTest.ok;
        } catch {
            healthChecks.elevenlabs = false;
        }
        
        try {
            const twilioTest = await fetch(`https://api.twilio.com/2010-04-01/Accounts/${TWILIO_ACCOUNT_SID}.json`, {
                headers: {
                    'Authorization': `Basic ${Buffer.from(`${TWILIO_ACCOUNT_SID}:${TWILIO_AUTH_TOKEN}`).toString('base64')}`
                }
            });
            healthChecks.twilio = twilioTest.ok;
        } catch {
            healthChecks.twilio = false;
        }
        
        res.json({
            ...healthChecks,
            stats: {
                totalMessages: stats.totalMessages,
                successfulTranslations: stats.successfulTranslations,
                errors: stats.errors,
                successRate: stats.totalMessages > 0 ? Math.round((stats.successfulTranslations / stats.totalMessages) * 100) : 0,
                averageProcessTime: stats.averageProcessTime
            }
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message, healthy: false });
    }
});

app.get('/api/stats', (req, res) => {
    res.json({
        totalMessages: stats.totalMessages,
        successfulTranslations: stats.successfulTranslations,
        errors: stats.errors,
        successRate: stats.totalMessages > 0 ? Math.round((stats.successfulTranslations / stats.totalMessages) * 100) : 0,
        averageProcessTime: stats.averageProcessTime,
        uptime: process.uptime()
    });
});

// Error handling
app.use((error, req, res, next) => {
    if (error instanceof multer.MulterError) {
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({ error: 'File too large. Maximum size is 25MB.' });
        }
    }
    
    console.error('Server error:', error);
    res.status(500).json({ error: 'Internal server error' });
});

// Create directories
const dirs = ['temp', 'public'];
dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`🚀 WhatsApp Voice Translator running on port ${PORT}`);
    console.log(`📍 Webhook URL: ${BASE_URL}/webhook`);
    console.log(`🌐 Web Interface: ${BASE_URL}`);
    console.log(`💊 Health Check: ${BASE_URL}/api/health`);
    console.log('✅ Ready to translate Russian 🇷🇺 → Portuguese 🇧🇷');
});
